package pt.ulisboa.tecnico.rnl.dei.deiint.main.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import pt.ulisboa.tecnico.rnl.dei.deiint.exceptions.DeiintException;
import pt.ulisboa.tecnico.rnl.dei.deiint.exceptions.ErrorMessage;
import pt.ulisboa.tecnico.rnl.dei.deiint.main.dto.RatingDto;
import pt.ulisboa.tecnico.rnl.dei.deiint.main.entity.Rating;
import pt.ulisboa.tecnico.rnl.dei.deiint.main.repository.RatingRepository;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class RatingService {
	@Autowired
	private RatingRepository ratingRepository;

	private Rating fetchRatingOrThrow(long id) {
		return ratingRepository.findById(id)
				.orElseThrow(() -> new DeiintException(ErrorMessage.NO_SUCH_RATING, Long.toString(id)));
	}

	// Probably could remove this ig
	public List<RatingDto> getAllRatings() {
		return ratingRepository.findAll().stream()
				.map(RatingDto::new)
				.collect(Collectors.toList());
	}

	public List<RatingDto> getRatingsByInterviewId(long id) {
		return ratingRepository.findAll().stream()
                .filter(r -> r.getInterviewId() == id)
                .map(RatingDto::new)
                .collect(Collectors.toList());
	}

	public RatingDto createRating(RatingDto ratingDto) {
		// Verify there isn't already a rating for the same examinerName and interviewId
		List<Rating> ratings = ratingRepository.findAll().stream().filter(
				r -> r.getExaminerName().equals(ratingDto.getExaminerName())).toList();
		if (ratings.stream().anyMatch(r -> r.getInterviewId() == ratingDto.getInterviewId())) {
            throw new DeiintException(ErrorMessage.ERR_EXISTING_RATING, Long.toString(ratingDto.getInterviewId()) +
					" " + ratingDto.getExaminerName());
        }

		Rating rating = new Rating(ratingDto);
		rating.setId(null); // to ensure that the id is generated by the database
		return new RatingDto(ratingRepository.save(rating));
	}

	public RatingDto getRating(long id) {
		return new RatingDto(fetchRatingOrThrow(id));
	}

	public RatingDto updateRating(long id, RatingDto ratingDto) {
		fetchRatingOrThrow(id); // ensure exists

		Rating rating = new Rating(ratingDto);
		rating.setId(id);
		return new RatingDto(ratingRepository.save(rating));
	}

	public void deleteRating(long id) {
		fetchRatingOrThrow(id); // ensure exists

		ratingRepository.deleteById(id);
	}
}
